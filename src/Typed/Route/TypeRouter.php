<?php

namespace Kiwilan\Typescriptable\Typed\Route;

use Closure;
use Illuminate\Routing\Route;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Route as FacadesRoute;
use Kiwilan\Typescriptable\TypescriptableConfig;

class TypeRouter
{
    /** @var TypeRoute[] */
    protected array $routes = [];

    protected function __construct(
        protected ?string $tsNamePaths = null,
        protected ?string $tsNames = null,
        protected ?string $tsPaths = null,
        protected ?string $tsParams = null,

        protected ?string $tsTypes = null,
        protected ?string $tsGlobalTypes = null,

        protected ?string $tsGlobalTypesGet = null,
        protected ?string $tsGlobalTypesPost = null,
        protected ?string $tsGlobalTypesPut = null,
        protected ?string $tsGlobalTypesPatch = null,
        protected ?string $tsGlobalTypesDelete = null,

        protected ?string $tsRoutes = null,

        protected ?string $typescript = null,
        protected ?string $typescriptRoutes = null,
    ) {
    }

    public static function make(?string $routeList = null): self
    {
        $type = new self();
        $type->routes = $type->fetchRoutes($routeList);

        $type->tsNamePaths = $type->setTsNamePaths();
        $type->tsNames = $type->setTsNames();
        $type->tsPaths = $type->setTsPaths();
        $type->tsParams = $type->setTsParams();

        $type->tsTypes = $type->setTsTypes();
        $type->tsGlobalTypes = $type->setTsGlobalTypes();

        $type->tsGlobalTypesGet = $type->setTsGlobalTypesMethod('GET');
        $type->tsGlobalTypesPost = $type->setTsGlobalTypesMethod('POST');
        $type->tsGlobalTypesPut = $type->setTsGlobalTypesMethod('PUT');
        $type->tsGlobalTypesPatch = $type->setTsGlobalTypesMethod('PATCH');
        $type->tsGlobalTypesDelete = $type->setTsGlobalTypesMethod('DELETE');

        $type->tsRoutes = $type->setTsRoutes();

        $type->typescript = $type->setTypescript();
        $type->typescriptRoutes = $type->setTypescriptRoutes();

        return $type;
    }

    public function typescript(): string
    {
        return $this->typescript;
    }

    public function setTypescript(): string
    {
        $this->tsNamePaths = empty($this->tsNames) ? 'never' : $this->tsNamePaths;
        $this->tsNames = empty($this->tsNames) ? 'never' : $this->tsNames;
        $this->tsPaths = empty($this->tsPaths) ? 'never' : $this->tsPaths;

        $this->tsGlobalTypes = empty($this->tsGlobalTypes) ? 'never' : $this->tsGlobalTypes;
        $this->tsGlobalTypesGet = empty($this->tsGlobalTypesGet) ? 'never' : $this->tsGlobalTypesGet;
        $this->tsGlobalTypesPost = empty($this->tsGlobalTypesPost) ? 'never' : $this->tsGlobalTypesPost;
        $this->tsGlobalTypesPut = empty($this->tsGlobalTypesPut) ? 'never' : $this->tsGlobalTypesPut;
        $this->tsGlobalTypesPatch = empty($this->tsGlobalTypesPatch) ? 'never' : $this->tsGlobalTypesPatch;
        $this->tsGlobalTypesDelete = empty($this->tsGlobalTypesDelete) ? 'never' : $this->tsGlobalTypesDelete;

        return <<<typescript
        // This file is auto generated by TypescriptableLaravel.
        declare namespace App {
          declare namespace Route {
            {$this->tsNamePaths}
            export type Name = {$this->tsNames}
            export type Path = {$this->tsPaths};
            export type Params = {
        {$this->tsParams}
            };

            export type Method = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
            export interface Entity { name: App.Route.Name; path: App.Route.Path; params?: App.Route.Params[Route.Name],  method: App.Route.Method; }

            declare namespace Typed {
        {$this->tsTypes}
            }
            export type Param = string | number | boolean | undefined
            export type Type = {$this->tsGlobalTypes}
            export type TypeGet = {$this->tsGlobalTypesGet}
            export type TypePost = {$this->tsGlobalTypesPost}
            export type TypePut = {$this->tsGlobalTypesPut}
            export type TypePatch = {$this->tsGlobalTypesPatch}
            export type TypeDelete = {$this->tsGlobalTypesDelete}
          }
        }
        typescript;
    }

    public function typescriptRoutes(): string
    {
        return $this->typescriptRoutes;
    }

    public function setTypescriptRoutes(): string
    {
        return <<<typescript
        // This file is auto generated by TypescriptableLaravel.
        const Routes: Record<App.Route.Name, App.Route.Entity> = {
        {$this->tsRoutes},
        }

        declare global {
          interface Window {
            Routes: Record<App.Route.Name, App.Route.Entity>
          }
        }

        if (typeof window !== undefined && typeof window.Routes !== undefined)
          window.Routes = Routes

        export { Routes }

        typescript;
    }

    public function setTsNamePaths(): string
    {
        return $this->collectRoutes(function (TypeRoute $route) {
            $name = TypescriptableConfig::routesUsePath()
                ? $route->fullUri()
                : $route->name();

            return "'{$name}'";
        }, ' | ');
    }

    private function setTsNames(): string
    {
        return $this->collectRoutes(function (TypeRoute $route) {
            return "'{$route->name()}'";
        }, ' | ');
    }

    private function setTsPaths(): string
    {
        return $this->collectRoutes(function (TypeRoute $route) {
            return "'{$route->fullUri()}'";
        }, ' | ');
    }

    private function setTsParams(): string
    {
        return $this->collectRoutes(function (TypeRoute $route) {
            $hasParams = count($route->parameters()) > 0;

            if ($hasParams) {
                $params = collect($route->parameters())
                    ->map(fn (TypeRouteParam $param) => "'{$param->name()}'?: App.Route.Param")
                    ->join(",\n");

                return "      '{$route->name()}': {\n        {$params}\n      }";
            } else {
                return "      '{$route->name()}': never";
            }
        }, ",\n");
    }

    private function setTsTypes(): string
    {
        return $this->collectRoutes(function (TypeRoute $route) {
            $params = '';

            if (empty($route->parameters())) {
                $params = 'params?: undefined';
            } else {
                $params = collect($route->parameters())
                    ->map(function (TypeRouteParam $param) {
                        $required = $param->required() ? '' : '?';

                        return "{$param->name()}{$required}: App.Route.Param,";
                    })
                    ->join(' ');
                $params = <<<typescript
                params: {
                          {$params}
                        }
                typescript;
            }

            return <<<typescript
                  type {$route->routeName()} = {
                    name: '{$route->pathType()}',
                    {$params},
                    query?: Record<string, App.Route.Param>,
                    hash?: string,
                  }
            typescript;
        }, ";\n");
    }

    private function setTsGlobalTypes(): string
    {
        return $this->collectRoutes(function (TypeRoute $route) {
            return <<<typescript
            App.Route.Typed.{$route->routeName()}
            typescript;
        }, ' | ');
    }

    private function setTsGlobalTypesMethod(string $method): string
    {
        $routes = $this->collectRoutesMethod($method);

        return collect($routes)
            ->map(function (TypeRoute $route) {
                return <<<typescript
                App.Route.Typed.{$route->routeName()}
                typescript;
            })->join(' | ');
    }

    private function setTsRoutes(): string
    {
        return $this->collectRoutes(function (TypeRoute $route) {
            $params = collect($route->parameters())
                ->map(fn (TypeRouteParam $param) => "{$param->name()}: 'string',");

            if ($params->isEmpty()) {
                $params = 'params: undefined';
            } else {
                $params = $params->join(' ');
                $params = <<<typescript
                params: {
                      {$params}
                    }
                typescript;
            }

            return <<<typescript
              '{$route->name()}': {
                name: '{$route->name()}',
                path: '{$route->fullUri()}',
                {$params},
                method: '{$route->methods()[0]}',
              }
            typescript;
        }, ",\n");
    }

    private function collectRoutesMethod(string $method): Collection
    {
        return collect($this->routes)
            ->filter(fn (TypeRoute $route) => $route->method() === $method);
    }

    private function collectRoutes(Closure $closure, ?string $join = null): string|Collection
    {
        $routes = collect($this->routes)
            ->map(fn (TypeRoute $route, string $key) => $closure($route, $key));

        if ($join) {
            return $routes->join($join);
        }

        return $routes;
    }

    private function fetchRoutes(?string $routeList = null): array
    {
        $items = collect([]);
        if ($routeList) {
            $content = file_get_contents($routeList);
            $content = json_decode($content);
            /** @var Collection<int, Route> $items */
            $items = collect($content);
        } else {
            /** @var Collection<int, Route> $items */
            $items = collect(FacadesRoute::getRoutes());
        }

        foreach ($items as $key => $item) {
            dump($item->uri());
        }
        /** @var TypeRoute[] $routes */
        $routes = $items->mapWithKeys(function (Route $route) {
            dump($route->uri());
            /** @var Route $id */
            $route = $route;
            $id = TypeRoute::generateId($route);

            return [$id => $route];
        })
        ->filter()
        ->map(fn (Route $route) => TypeRoute::make($route))
        ->toArray();

        dd($routes);

        // for testing
        // file_put_contents(
        //     database_path('routes.json'),
        //     json_encode(collect(FacadesRoute::getRoutes())->toArray(), JSON_PRETTY_PRINT)
        // );
        $list = [];

        foreach ($routes as $id => $route) {
            if (! $this->skipRouteName($route)) {
                $list[$id] = $route;
            }
        }

        foreach ($list as $route) {
            if ($this->skipRoutePath($route)) {
                unset($list[$route->name()]);
            }
        }

        return $list;
    }

    private function skipRouteName(TypeRoute $route): bool
    {
        $skip_name = [];
        $skippable_name = TypescriptableConfig::routesSkipName();

        foreach ($skippable_name as $item) {
            $item = str_replace('.*', '', $item);
            array_push($skip_name, $item);
        }

        foreach ($skip_name as $type => $item) {
            if (str_starts_with($route->name(), $item)) {
                return true;
            }
        }

        return false;
    }

    private function skipRoutePath(TypeRoute $route): bool
    {
        $skip_path = [];
        $skippable_path = TypescriptableConfig::routesSkipPath();

        foreach ($skippable_path as $item) {
            $item = str_replace('/*', '', $item);
            array_push($skip_path, $item);
        }

        foreach ($skip_path as $type => $item) {
            if (str_starts_with($route->uri(), $item)) {
                return true;
            }
        }

        return false;
    }
}
