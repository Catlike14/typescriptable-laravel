<?php

namespace Kiwilan\Typescriptable\Services\Typescriptable;

use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;
use Kiwilan\Typescriptable\Services\Typescriptable\Utils\TypescriptableDbColumn;
use Kiwilan\Typescriptable\Services\Typescriptable\Utils\TypescriptableTeam;
use ReflectionMethod;
use ReflectionNamedType;

/**
 * @property string $table
 * @property TypescriptableClass|null $class
 * @property TypescriptableProperty[] $columns
 * @property TypescriptableRelation[] $relations
 * @property string[] $appends
 * @property TypescriptableProperty[] $properties
 */
class TypescriptableModel
{
    public function __construct(
        public ?string $table = null,
        public ?string $name = null,
        public ?TypescriptableClass $class = null,
        /** @var TypescriptableProperty[] */
        public array $columns = [],
        /** @var TypescriptableRelation[] */
        public array $relations = [],
        public array $appends = [],
        public ?string $mediable = null,
        /** @var TypescriptableProperty[] */
        public array $properties = [],
        public array $counts = [],
        public ?string $tsString = null,
        public ?string $phpString = null,
    ) {
    }

    public static function make(TypescriptableClass $class): self
    {
        $parser = new self(table: $class->table, name: $class->name, class: $class);

        /** @var TypescriptableDbColumn[] */
        $dbColumns = DB::select(DB::raw("SHOW COLUMNS FROM {$class->table}"));

        foreach ($dbColumns as $column) {
            $column = TypescriptableDbColumn::make($column);
            $parser->columns[$column->Field] = TypescriptableProperty::make($class->table, $column);
        }

        $parser->setAppends();
        $parser->setRelations();
        $parser->setCounts();

        if ($parser->class->command?->fakeTeam && $parser->class->name === 'User') {
            $parser->setFakeTeam();
        }
        $parser->setProperties();

        foreach ($parser->properties as $field => $property) {
            $parser->properties[$field] = $property->convertCastType($field, $parser->class->casts);
            $parser->properties[$field] = $property->convertDateType($parser->class->dates);
            $parser->properties[$field] = $property->setAdvancedType();
            $parser->properties[$field] = $property->setTsType();
        }

        $parser->tsString = $parser->convertToTs();
        $parser->phpString = $parser->convertToPhp();

        return $parser;
    }

    /**
     * @param  TypescriptableProperty[]  $properties
     */
    public static function fake(TypescriptableClass $class, array $properties): self
    {
        $model = new self(table: $class->table, name: $class->name, class: $class, columns: $properties);
        $model->setProperties();

        foreach ($model->properties as $field => $property) {
            $model->properties[$field] = $property->setTsType();
        }
        $model->tsString = $model->convertToTs();

        return $model;
    }

    private function setCounts()
    {
        foreach ($this->relations as $field => $relation) {
            if ($relation->isArray) {
                $this->counts[$field] = $relation->type;
            }
        }
    }

    private function convertToPhp(): string
    {
        $php[] = '<?php';
        $php[] = '';
        $php[] = 'namespace App\Types;';
        $php[] = '';
        $php[] = '// This file is auto generated by GenerateTypeCommand.';
        $php[] = "class {$this->class->name}";
        $php[] = '{';

        foreach ($this->properties as $property) {
            $php[] = $property->phpString;
        }

        $php[] = '};';
        $php[] = '';

        return implode(PHP_EOL, $php);
    }

    private function convertToTs(): string
    {
        $typescript[] = "export type {$this->class->name} = {";

        foreach ($this->properties as $property) {
            $typescript[] = "  {$property->tsString}";
        }

        $typescript[] = '    };';

        return implode(PHP_EOL, $typescript);
    }

    private function setFakeTeam()
    {
        $this->properties = TypescriptableTeam::setUserFakeTeam();
    }

    private function setRelations()
    {
        $this->relations = TypescriptableRelation::make($this);
    }

    private function setProperties()
    {
        foreach ($this->columns as $column) {
            if (! in_array($column->name, $this->class->hidden)) {
                $this->properties[$column->name] = $column;
            }
        }

        foreach ($this->appends as $field => $type) {
            $this->properties[$field] = TypescriptableProperty::make(
                table: $this->table,
                dbColumn: new TypescriptableDbColumn($field, $type),
                isAppend: true,
            );
        }

        foreach ($this->relations as $field => $relation) {
            $this->properties[$field] = TypescriptableProperty::make(
                table: $this->class->table,
                dbColumn: new TypescriptableDbColumn($field, $relation->type),
                overrideTsType: true,
                isRelation: true,
                isArray: $relation->isArray,
            );
        }

        foreach ($this->counts as $field => $type) {
            $this->properties["{$field}_count"] = TypescriptableProperty::make(
                table: $this->class->table,
                dbColumn: new TypescriptableDbColumn("{$field}_count", 'number'),
                overrideTsType: true,
                isCount: true,
            );
        }

        if ($this->mediable) {
            $this->properties['mediable'] = TypescriptableProperty::make(
                table: $this->table,
                dbColumn: new TypescriptableDbColumn('mediable', $this->mediable),
                overrideTsType: true,
            );
        }
    }

    private function setAppends()
    {
        foreach ($this->class->reflector->getMethods() as $key => $method) {
            $name = $method->getName();
            $return = $method->getReturnType();

            if ($name !== 'getMediableAttribute') {
                if ($return instanceof ReflectionNamedType && $return->getName() === 'Illuminate\Database\Eloquent\Casts\Attribute') {
                    $this->setAppendMethod($name, $method);
                }

                if (str_starts_with($name, 'get') && str_ends_with($name, 'Attribute') && $name !== 'getAttribute') {
                    $this->setAppendMethod($name, $method);
                }
            } else {
                $this->setMediable();
            }
        }
    }

    private function setAppendMethod(string $name, ReflectionMethod $method)
    {
        $field = str_replace('Attribute', '', str_replace('get', '', $name));
        $field = Str::snake($field);

        $doc = $method->getDocComment();
        $return = null;

        $regex = '/(?m)@return *\K(?>(\S+) *)??(\S+)$/';

        if (preg_match($regex, $doc, $matches)) {
            $return = $matches[0] ?? null;
        }

        $type = $method->getReturnType();

        if ($return) {
            $type = $return;
        }

        if ($type instanceof ReflectionNamedType) {
            $type = $type->getName();
        }

        $this->appends[$field] = $type;
    }

    private function setMediable(): self
    {
        $reflector = $this->class->reflector->getMethods();
        $names = array_map(fn ($method) => $method->getName(), $reflector);

        $mediable_object = null;

        if (in_array('getMediablesListAttribute', $names) && method_exists($this->class->model, 'getMediablesListAttribute')) {
            $mediable_object = '{';

            foreach ($this->class->model->getMediablesListAttribute() as $media) {
                $mediable_object .= " {$media}?: string, ";
            }
            $mediable_object .= '}';
        }

        $this->mediable = $mediable_object;

        return $this;
    }
}
